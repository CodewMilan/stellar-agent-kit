/**
 * SoroSwap DeFi integration â€“ quote and execute swaps via aggregator.
 *
 * RESEARCH (in comments):
 * 1) SoroSwap testnet aggregator contract ID
 *    - Source: https://github.com/soroswap/core/blob/main/public/testnet.contracts.json
 *    - Testnet "router" (aggregator): CCJUD55AG6W5HAI5LRVNKAE5WDP5XGZBUDS5WNTIVDU7O264UZZE7BRD
 *    - Mainnet SoroswapRouter: CAG5LRYQ5JVEUI5TEID72EYOVX44TTUJT5BQR2J6J77FH65PCCFAJDDH
 *
 * 2) Soroban invoke parameters for aggregator
 *    - Quote: SoroSwap exposes quote via REST API (POST /quote). Direct contract "get_quote" / "quote"
 *      is not documented in public docs; API returns expectedIn, expectedOut, route. For contract-only
 *      path, use simulateTransaction on an invoke of the router with the view function name/args once
 *      published by SoroSwap.
 *    - Swap execution: API POST /quote/build returns XDR; sign and submit via Soroban RPC sendTransaction.
 *
 * 3) Uses rpc.Server (Soroban RPC) from @stellar/stellar-sdk for simulation and sendTransaction.
 */
import { z } from "zod";
import { Contract, Address, Keypair, TransactionBuilder, Networks, nativeToScVal, xdr, } from "@stellar/stellar-sdk";
import { rpc } from "@stellar/stellar-sdk";
import { getNetworkConfig } from "../config/networks.js";
export const AssetSchema = z.object({
    contractId: z.string().regex(/^C[A-Z2-7]{55}$/, "Invalid Soroban contract ID (C...)"),
});
export const QuoteResponseSchema = z.object({
    expectedIn: z.string(),
    expectedOut: z.string(),
    minOut: z.string(),
    route: z.array(z.string()),
});
// ---------------------------------------------------------------------------
// SoroSwap contract IDs (research)
// ---------------------------------------------------------------------------
const SOROSWAP_AGGREGATOR_TESTNET = "CCJUD55AG6W5HAI5LRVNKAE5WDP5XGZBUDS5WNTIVDU7O264UZZE7BRD";
const SOROSWAP_AGGREGATOR_MAINNET = "CAG5LRYQ5JVEUI5TEID72EYOVX44TTUJT5BQR2J6J77FH65PCCFAJDDH";
/** Known testnet token contract IDs for quick tests (SoroSwap docs). */
export const TESTNET_ASSETS = {
    XLM: "CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC",
    USDC: "CBBHRKEP5M3NUDRISGLJKGHDHX3DA2CN2AZBQY6WLVUJ7VNLGSKBDUCM",
};
// ---------------------------------------------------------------------------
// API base (SoroSwap Swap Route API)
// ---------------------------------------------------------------------------
const SOROSWAP_API_BASE = "https://api.soroswap.finance";
// ---------------------------------------------------------------------------
// SoroSwapClient
// ---------------------------------------------------------------------------
export class SoroSwapClient {
    sorobanServer;
    networkConfig;
    apiKey;
    constructor(networkConfig, apiKey) {
        this.networkConfig = networkConfig;
        this.sorobanServer = new rpc.Server(networkConfig.sorobanRpcUrl, {
            allowHttp: networkConfig.sorobanRpcUrl.startsWith("http:"),
        });
        this.apiKey = apiKey ?? process.env.SOROSWAP_API_KEY;
    }
    /**
     * Get a swap quote: expected in/out, minOut, route.
     * Uses SoroSwap aggregator: first tries REST API (if API key set), then falls back to
     * simulating an aggregator contract call via Soroban RPC (view-style invocation).
     */
    async getQuote(fromAsset, toAsset, amount) {
        const fromParsed = AssetSchema.safeParse(fromAsset);
        const toParsed = AssetSchema.safeParse(toAsset);
        if (!fromParsed.success) {
            throw new Error(`Invalid fromAsset: ${fromParsed.error.message}`);
        }
        if (!toParsed.success) {
            throw new Error(`Invalid toAsset: ${toParsed.error.message}`);
        }
        const amountStr = String(amount).trim();
        if (!amountStr || !/^\d+$/.test(amountStr)) {
            throw new Error("Amount must be a non-negative integer string (raw units)");
        }
        if (this.apiKey) {
            return this.getQuoteViaApi(fromParsed.data.contractId, toParsed.data.contractId, amountStr);
        }
        return this.getQuoteViaContract(fromParsed.data, toParsed.data, amountStr);
    }
    async getQuoteViaApi(assetIn, assetOut, amount) {
        const network = this.networkConfig.horizonUrl.includes("testnet") ? "testnet" : "mainnet";
        const url = `${SOROSWAP_API_BASE}/quote?network=${network}`;
        const body = {
            assetIn,
            assetOut,
            amount,
            tradeType: "EXACT_IN",
            protocols: ["soroswap", "phoenix", "aqua"],
        };
        const headers = {
            "Content-Type": "application/json",
        };
        if (this.apiKey) {
            headers["Authorization"] = `Bearer ${this.apiKey}`;
        }
        const res = await fetch(url, {
            method: "POST",
            headers,
            body: JSON.stringify(body),
        });
        if (!res.ok) {
            const text = await res.text();
            let message = `SoroSwap API error ${res.status}: ${text}`;
            if (res.status === 403) {
                message =
                    "SoroSwap API 403: check SOROSWAP_API_KEY (Bearer sk_...) and base URL.";
            }
            throw new Error(message);
        }
        const data = (await res.json());
        return parseApiQuoteToQuoteResponse(data);
    }
    /**
     * Fallback: simulate aggregator contract call via Soroban RPC.
     * Contract ID and invoke signature are from research; exact method name may vary.
     * If the aggregator exposes a view (e.g. get_amounts_out), we build a read-only invoke and parse result.
     */
    async getQuoteViaContract(fromAsset, toAsset, amount) {
        const contractId = this.networkConfig.horizonUrl.includes("testnet")
            ? SOROSWAP_AGGREGATOR_TESTNET
            : SOROSWAP_AGGREGATOR_MAINNET;
        const contract = new Contract(contractId);
        const fromAddr = new Address(fromAsset.contractId);
        const toAddr = new Address(toAsset.contractId);
        const amountScVal = nativeToScVal(amount, { type: "i128" });
        // Common DEX pattern: get_amounts_out(amount_in, path[]). Path = [from, to].
        // SoroSwap router may use different name; adjust when docs are available.
        const pathScVal = xdr.ScVal.scvVec([
            nativeToScVal(fromAddr),
            nativeToScVal(toAddr),
        ]);
        const op = contract.call("get_amounts_out", amountScVal, pathScVal);
        const networkPassphrase = this.networkConfig.horizonUrl.includes("testnet")
            ? Networks.TESTNET
            : Networks.PUBLIC;
        const sourceAccount = await this.sorobanServer.getAccount("GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHF" // system account for simulation
        );
        const tx = new TransactionBuilder(sourceAccount, {
            fee: "10000",
            networkPassphrase,
        })
            .addOperation(op)
            .setTimeout(30)
            .build();
        let sim;
        try {
            sim = await this.sorobanServer.simulateTransaction(tx);
        }
        catch (err) {
            const msg = err instanceof Error ? err.message : String(err);
            throw new Error(`SoroSwap quote simulation failed (aggregator may use different method/args): ${msg}. Set SOROSWAP_API_KEY for API-based quotes.`);
        }
        if ("error" in sim && sim.error) {
            throw new Error(`SoroSwap quote simulation error: ${JSON.stringify(sim.error)}. Use SOROSWAP_API_KEY for API quotes.`);
        }
        const result = sim;
        const retvalB64 = result?.result?.retval;
        if (!retvalB64) {
            throw new Error("SoroSwap quote: no retval in simulation. Use SOROSWAP_API_KEY for API quotes.");
        }
        const retval = xdr.ScVal.fromXDR(retvalB64, "base64");
        const vec = retval.vec();
        if (!vec || vec.length < 2) {
            throw new Error("SoroSwap quote: unexpected contract return format. Use SOROSWAP_API_KEY for API quotes.");
        }
        const amountInVal = vec[0];
        const amountOutVal = vec[1];
        const expectedIn = scValToI128String(amountInVal);
        const expectedOut = scValToI128String(amountOutVal);
        const route = [fromAsset.contractId, toAsset.contractId];
        return QuoteResponseSchema.parse({
            expectedIn,
            expectedOut,
            minOut: expectedOut,
            route,
        });
    }
    /**
     * Execute a swap: build (from quote), sign with fromSecret, submit via Soroban RPC.
     */
    async executeSwap(fromSecret, quote, network) {
        const config = getNetworkConfig(network);
        const server = new rpc.Server(config.sorobanRpcUrl, {
            allowHttp: config.sorobanRpcUrl.startsWith("http:"),
        });
        const keypair = Keypair.fromSecret(fromSecret);
        const fromAddress = keypair.publicKey();
        if (!this.apiKey) {
            throw new Error("executeSwap requires SoroSwap API to build the transaction. Set SOROSWAP_API_KEY.");
        }
        const networkName = config.horizonUrl.includes("testnet") ? "testnet" : "mainnet";
        const buildUrl = `${SOROSWAP_API_BASE}/quote/build?network=${networkName}`;
        const buildBody = {
            quote,
            from: fromAddress,
            to: fromAddress,
        };
        const buildRes = await fetch(buildUrl, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${this.apiKey}`,
            },
            body: JSON.stringify(buildBody),
        });
        if (!buildRes.ok) {
            const text = await buildRes.text();
            throw new Error(`SoroSwap build failed ${buildRes.status}: ${text}`);
        }
        const buildData = (await buildRes.json());
        const xdrBase64 = buildData?.xdr;
        if (!xdrBase64 || typeof xdrBase64 !== "string") {
            throw new Error("SoroSwap build response missing xdr");
        }
        const networkPassphrase = config.horizonUrl.includes("testnet")
            ? Networks.TESTNET
            : Networks.PUBLIC;
        const tx = TransactionBuilder.fromXDR(xdrBase64, networkPassphrase);
        tx.sign(keypair);
        const sendResult = await server.sendTransaction(tx);
        if (sendResult.errorResult) {
            throw new Error(`Soroban sendTransaction failed: ${String(sendResult.errorResult)}`);
        }
        return {
            hash: sendResult.hash,
            status: sendResult.status ?? "PENDING",
        };
    }
}
// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------
function parseApiQuoteToQuoteResponse(data) {
    const o = data;
    const expectedIn = String(o?.expectedIn ?? o?.amountIn ?? "0");
    const expectedOut = String(o?.expectedOut ?? o?.amountOut ?? "0");
    const minOut = String(o?.minOut ?? o?.minimumAmountOut ?? expectedOut);
    const route = Array.isArray(o?.route)
        ? o.route
        : Array.isArray(o?.path)
            ? o.path
            : [];
    return QuoteResponseSchema.parse({
        expectedIn,
        expectedOut,
        minOut,
        route,
    });
}
function scValToI128String(scv) {
    const iv = scv.i128?.() ?? scv.value?.();
    if (!iv)
        return "0";
    const lo = typeof iv.lo === "function" ? iv.lo()?.toString() : String(iv.lo ?? 0);
    const hi = typeof iv.hi === "function" ? iv.hi()?.toString() : String(iv.hi ?? 0);
    if (hi === "0" || hi === "undefined")
        return lo;
    try {
        return (BigInt(hi) * (1n << 64n) + BigInt(lo)).toString();
    }
    catch {
        return lo;
    }
}
//# sourceMappingURL=soroSwapClient.js.map